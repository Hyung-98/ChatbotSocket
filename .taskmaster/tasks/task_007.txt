# Task ID: 7
# Title: 채팅 UI 구현 (Next.js)
# Status: pending
# Dependencies: 1, 6
# Priority: high
# Description: Next.js로 채팅 인터페이스를 구현하여 메시지 표시, 입력, 스트리밍 응답 시각화
# Details:
1. 채팅방 컴포넌트 구현
2. 메시지 목록 및 입력 폼 구현
3. 스트리밍 응답 시각화 (타이핑 효과)
4. 메시지 상태 관리 (Zustand)
5. 반응형 디자인 적용

```typescript
// frontend/src/store/chatStore.ts
import { create } from 'zustand';

type Message = {
  id: string;
  content: string;
  role: 'user' | 'bot';
  createdAt: string;
  userId?: string;
};

type ChatStore = {
  messages: Record<string, Message[]>; // roomId -> messages
  currentRoomId: string | null;
  isStreaming: boolean;
  streamingContent: string;
  addMessage: (roomId: string, message: Message) => void;
  setCurrentRoom: (roomId: string) => void;
  startStreaming: () => void;
  appendStreamContent: (content: string) => void;
  endStreaming: (roomId: string) => void;
  setMessages: (roomId: string, messages: Message[]) => void;
};

export const useChatStore = create<ChatStore>((set) => ({
  messages: {},
  currentRoomId: null,
  isStreaming: false,
  streamingContent: '',
  
  addMessage: (roomId, message) => set((state) => ({
    messages: {
      ...state.messages,
      [roomId]: [...(state.messages[roomId] || []), message],
    },
  })),
  
  setCurrentRoom: (roomId) => set({ currentRoomId: roomId }),
  
  startStreaming: () => set({ isStreaming: true, streamingContent: '' }),
  
  appendStreamContent: (content) => set((state) => ({
    streamingContent: state.streamingContent + content,
  })),
  
  endStreaming: (roomId) => set((state) => {
    if (!state.currentRoomId) return state;
    
    const newMessage: Message = {
      id: Date.now().toString(),
      content: state.streamingContent,
      role: 'bot',
      createdAt: new Date().toISOString(),
    };
    
    return {
      isStreaming: false,
      streamingContent: '',
      messages: {
        ...state.messages,
        [roomId]: [...(state.messages[roomId] || []), newMessage],
      },
    };
  }),
  
  setMessages: (roomId, messages) => set((state) => ({
    messages: {
      ...state.messages,
      [roomId]: messages,
    },
  })),
}));
```

```tsx
// frontend/src/app/chat/[roomId]/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useParams } from 'next/navigation';
import { useSocket } from '@/hooks/useSocket';
import { useChatStore } from '@/store/chatStore';
import MessageList from '@/components/MessageList';
import MessageInput from '@/components/MessageInput';

export default function ChatRoom() {
  const params = useParams();
  const roomId = params.roomId as string;
  const { socket, joinRoom, leaveRoom, sendMessage } = useSocket();
  const { messages, isStreaming, streamingContent, addMessage, startStreaming, appendStreamContent, endStreaming, setMessages } = useChatStore();
  
  useEffect(() => {
    if (!socket) return;
    
    joinRoom(roomId);
    
    // 기존 메시지 로드
    fetch(`/api/rooms/${roomId}/messages`)
      .then(res => res.json())
      .then(data => setMessages(roomId, data));
    
    // 메시지 수신 이벤트
    socket.on('message', (data) => {
      addMessage(roomId, {
        id: Date.now().toString(),
        content: data.text,
        role: data.userId ? 'user' : 'bot',
        createdAt: data.ts,
        userId: data.userId,
      });
    });
    
    // 스트리밍 이벤트
    socket.on('stream', (data) => {
      if (data.start) {
        startStreaming();
      } else if (data.end) {
        endStreaming(roomId);
      } else {
        appendStreamContent(data.token);
      }
    });
    
    return () => {
      leaveRoom(roomId);
      socket.off('message');
      socket.off('stream');
    };
  }, [socket, roomId]);
  
  const handleSendMessage = (text: string) => {
    sendMessage(roomId, text);
    
    // 낙관적 업데이트
    addMessage(roomId, {
      id: Date.now().toString(),
      content: text,
      role: 'user',
      createdAt: new Date().toISOString(),
    });
  };
  
  return (
    <div className="flex flex-col h-screen">
      <div className="flex-1 overflow-y-auto p-4">
        <MessageList 
          messages={messages[roomId] || []} 
          isStreaming={isStreaming}
          streamingContent={streamingContent}
        />
      </div>
      <div className="p-4 border-t">
        <MessageInput onSendMessage={handleSendMessage} disabled={isStreaming} />
      </div>
    </div>
  );
}
```

# Test Strategy:
1. 컴포넌트 렌더링 테스트
2. 메시지 표시 및 스크롤 동작 테스트
3. 메시지 입력 및 전송 테스트
4. 스트리밍 응답 시각화 테스트
5. 다양한 화면 크기에서 반응형 디자인 테스트
