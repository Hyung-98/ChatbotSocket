# Task ID: 4
# Title: Socket.IO 게이트웨이 구현 (NestJS)
# Status: pending
# Dependencies: 1, 3
# Priority: high
# Description: NestJS에서 Socket.IO 게이트웨이를 구현하여 실시간 양방향 통신 기능 구현
# Details:
1. NestJS WebSocket 게이트웨이 모듈 생성
2. Socket.IO 서버 설정 (CORS, 핸드셰이크 등)
3. 소켓 이벤트 핸들러 구현 (join, leave, send)
4. 인증 미들웨어와 연동
5. 에러 핸들링 및 로깅

```typescript
// backend/src/chat/chat.gateway.ts
import { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayConnection, OnGatewayDisconnect } from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { AuthService } from '../auth/auth.service';

@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL,
    credentials: true,
  },
})
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;

  constructor(private authService: AuthService) {}

  async handleConnection(client: Socket) {
    try {
      const token = client.handshake.auth.token;
      if (!token) {
        client.disconnect();
        return;
      }
      
      const user = await this.authService.validateToken(token);
      if (!user) {
        client.disconnect();
        return;
      }
      
      client.data.user = user;
      console.log(`Client connected: ${user.id}`);
    } catch (error) {
      client.disconnect();
    }
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
  }

  @SubscribeMessage('join')
  handleJoin(client: Socket, payload: { roomId: string }) {
    client.join(payload.roomId);
    return { event: 'joined', data: payload };
  }

  @SubscribeMessage('leave')
  handleLeave(client: Socket, payload: { roomId: string }) {
    client.leave(payload.roomId);
    return { event: 'left', data: payload };
  }

  @SubscribeMessage('send')
  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {
    const user = client.data.user;
    
    // 메시지 저장 로직은 별도 서비스로 분리
    
    this.server.to(payload.roomId).emit('message', {
      userId: user.id,
      text: payload.text,
      ts: new Date().toISOString()
    });
    
    // 챗봇 응답 처리는 별도 이벤트로 구현
    
    return { event: 'sent', data: payload };
  }
}
```

# Test Strategy:
1. 소켓 연결/연결 해제 테스트
2. 인증 실패 시 연결 거부 테스트
3. 룸 참가/퇴장 이벤트 테스트
4. 메시지 전송 및 브로드캐스트 테스트
5. 동시 다중 클라이언트 테스트
