# Task ID: 6
# Title: 프론트엔드 Socket.IO 클라이언트 구현
# Status: pending
# Dependencies: 1, 3, 4
# Priority: high
# Description: Next.js 14 App Router에서 Socket.IO 클라이언트를 구현하여 실시간 메시지 송수신 기능 구현
# Details:
1. socket.io-client 설치 및 설정
2. 소켓 연결 관리 커스텀 훅 구현
3. 인증 토큰 연동
4. 이벤트 핸들러 구현 (message, stream 등)
5. 재연결 로직 구현

```typescript
// frontend/src/lib/socket.ts
import { io, Socket } from 'socket.io-client';
import { getSession } from 'next-auth/react';

let socket: Socket | null = null;

export const initializeSocket = async (): Promise<Socket> => {
  if (socket) return socket;
  
  const session = await getSession();
  if (!session) throw new Error('Authentication required');
  
  socket = io(process.env.NEXT_PUBLIC_SOCKET_URL as string, {
    auth: {
      token: session.accessToken,
    },
    reconnectionAttempts: 5,
    reconnectionDelay: 1000,
  });
  
  socket.on('connect', () => {
    console.log('Socket connected');
  });
  
  socket.on('disconnect', () => {
    console.log('Socket disconnected');
  });
  
  socket.on('connect_error', (err) => {
    console.error('Connection error:', err.message);
  });
  
  return socket;
};

export const getSocket = (): Socket => {
  if (!socket) {
    throw new Error('Socket not initialized');
  }
  return socket;
};

export const closeSocket = (): void => {
  if (socket) {
    socket.disconnect();
    socket = null;
  }
};
```

```typescript
// frontend/src/hooks/useSocket.ts
import { useState, useEffect, useCallback } from 'react';
import { Socket } from 'socket.io-client';
import { initializeSocket, closeSocket } from '@/lib/socket';

export const useSocket = () => {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    const connectSocket = async () => {
      try {
        const socketInstance = await initializeSocket();
        setSocket(socketInstance);
        
        socketInstance.on('connect', () => setIsConnected(true));
        socketInstance.on('disconnect', () => setIsConnected(false));
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Failed to connect'));
      }
    };
    
    connectSocket();
    
    return () => {
      closeSocket();
    };
  }, []);
  
  const joinRoom = useCallback((roomId: string) => {
    if (socket && isConnected) {
      socket.emit('join', { roomId });
    }
  }, [socket, isConnected]);
  
  const leaveRoom = useCallback((roomId: string) => {
    if (socket && isConnected) {
      socket.emit('leave', { roomId });
    }
  }, [socket, isConnected]);
  
  const sendMessage = useCallback((roomId: string, text: string) => {
    if (socket && isConnected) {
      socket.emit('send', { roomId, text });
    }
  }, [socket, isConnected]);
  
  return { socket, isConnected, error, joinRoom, leaveRoom, sendMessage };
};
```

# Test Strategy:
1. 소켓 연결/연결 해제 테스트
2. 인증 토큰 전달 테스트
3. 이벤트 송수신 테스트
4. 네트워크 단절 시 재연결 테스트
5. 다양한 브라우저 환경에서 호환성 테스트
