# Task ID: 10
# Title: 벡터 검색 기반 RAG(Retrieval Augmented Generation) 구현
# Status: pending
# Dependencies: 2, 8
# Priority: medium
# Description: pgvector를 활용하여 이전 대화 내용을 벡터화하고 검색하여 챗봇의 컨텍스트 인식 능력 향상
# Details:
1. pgvector 확장 설정
2. 메시지 임베딩 생성 및 저장 로직 구현
3. 유사도 기반 관련 메시지 검색 구현
4. LLM 프롬프트에 검색 결과 통합
5. 임베딩 캐싱 및 최적화

```sql
-- PostgreSQL에 pgvector 확장 설치
CREATE EXTENSION IF NOT EXISTS vector;

-- 임베딩 필드 추가 (이미 Prisma 스키마에 정의됨)
ALTER TABLE "Message" ADD COLUMN IF NOT EXISTS embedding vector(1536);
```

```typescript
// backend/src/embedding/embedding.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PrismaService } from '../prisma/prisma.service';
import OpenAI from 'openai';

@Injectable()
export class EmbeddingService {
  private readonly openai: OpenAI;
  private readonly logger = new Logger(EmbeddingService.name);
  
  constructor(
    private configService: ConfigService,
    private prismaService: PrismaService,
  ) {
    this.openai = new OpenAI({
      apiKey: this.configService.get<string>('OPENAI_API_KEY'),
    });
  }
  
  async createEmbedding(text: string): Promise<number[]> {
    try {
      const response = await this.openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: text,
      });
      
      return response.data[0].embedding;
    } catch (error) {
      this.logger.error(`Failed to create embedding: ${error.message}`);
      throw error;
    }
  }
  
  async storeMessageEmbedding(messageId: string, content: string): Promise<void> {
    try {
      const embedding = await this.createEmbedding(content);
      
      await this.prismaService.$executeRaw`
        UPDATE "Message"
        SET embedding = ${embedding}::vector
        WHERE id = ${messageId}
      `;
    } catch (error) {
      this.logger.error(`Failed to store message embedding: ${error.message}`);
    }
  }
  
  async findSimilarMessages(content: string, roomId: string, limit: number = 5): Promise<any[]> {
    try {
      const embedding = await this.createEmbedding(content);
      
      const similarMessages = await this.prismaService.$queryRaw`
        SELECT id, content, role, "createdAt", "userId",
               1 - (embedding <=> ${embedding}::vector) as similarity
        FROM "Message"
        WHERE "roomId" = ${roomId}
          AND embedding IS NOT NULL
        ORDER BY similarity DESC
        LIMIT ${limit}
      `;
      
      return similarMessages;
    } catch (error) {
      this.logger.error(`Failed to find similar messages: ${error.message}`);
      return [];
    }
  }
}
```

```typescript
// backend/src/chat/chat.gateway.ts (수정)
import { EmbeddingService } from '../embedding/embedding.service';

@WebSocketGateway()
export class ChatGateway {
  constructor(
    // 기존 의존성...
    private embeddingService: EmbeddingService,
  ) {}
  
  @SubscribeMessage('send')
  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {
    // 기존 코드...
    
    // 사용자 메시지 저장 후 임베딩 생성 (비동기로 처리)
    const userMessage = await this.prismaService.message.create({
      data: {
        content: payload.text,
        role: 'user',
        roomId: payload.roomId,
        userId: user.id,
      },
    });
    
    // 비동기로 임베딩 생성 및 저장
    this.embeddingService.storeMessageEmbedding(userMessage.id, payload.text)
      .catch(err => console.error('Failed to store embedding:', err));
    
    // 유사 메시지 검색
    const similarMessages = await this.embeddingService.findSimilarMessages(
      payload.text,
      payload.roomId,
    );
    
    // 대화 기록 조회 (최근 메시지)
    const recentMessages = await this.prismaService.message.findMany({
      where: { roomId: payload.roomId },
      orderBy: { createdAt: 'desc' },
      take: 5,
    });
    
    // LLM 컨텍스트 구성 (시스템 프롬프트 + 유사 메시지 + 최근 메시지)
    const context = [
      { role: 'system', content: 'You are a helpful assistant.' },
      // 유사 메시지 추가
      ...similarMessages.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
      // 최근 메시지 추가 (중복 제거)
      ...recentMessages
        .filter(msg => !similarMessages.some(sm => sm.id === msg.id))
        .map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
      // 현재 사용자 메시지
      { role: 'user', content: payload.text },
    ];
    
    // LLM 응답 생성 (기존 코드와 동일)
    // ...
  }
}
```

# Test Strategy:
1. pgvector 설치 및 설정 테스트
2. 임베딩 생성 및 저장 테스트
3. 유사도 검색 정확도 테스트
4. 컨텍스트 통합 및 LLM 응답 품질 테스트
5. 성능 및 지연 시간 테스트
