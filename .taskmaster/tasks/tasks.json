{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 환경 설정 및 모노레포 구성",
        "description": "Next.js 14와 NestJS 기반의 모노레포 프로젝트 구조를 설정하고 Docker Compose로 개발 환경 구성",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. Turborepo 또는 Nx를 사용하여 모노레포 설정\n2. 프론트엔드(Next.js 14 App Router)와 백엔드(NestJS) 프로젝트 생성\n3. TypeScript 설정 및 공유 타입 디렉토리 구성\n4. ESLint, Prettier 등 코드 품질 도구 설정\n5. Docker Compose 파일 작성 (PostgreSQL, Redis 포함)\n6. 개발 환경 스크립트 구성 (dev, build, test)\n\n```bash\n# 모노레포 설정 예시 (Turborepo 사용)\nnpx create-turbo@latest\n\n# apps/frontend 디렉토리에 Next.js 설정\ncd apps/frontend\nnpx create-next-app@latest . --typescript --eslint --app --src-dir\n\n# apps/backend 디렉토리에 NestJS 설정\ncd ../backend\nnest new . --package-manager npm\n\n# Docker Compose 파일 작성\ntouch docker-compose.yml\n```\n\n```yaml\n# docker-compose.yml 예시\nversion: '3.8'\nservices:\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_PASSWORD: postgres\n      POSTGRES_DB: chatbot\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:alpine\n    ports:\n      - \"6379:6379\"\n\nvolumes:\n  postgres_data:\n```",
        "testStrategy": "1. 모노레포 빌드 스크립트 실행 테스트\n2. Docker Compose 환경 실행 및 접속 테스트\n3. 프론트엔드/백엔드 개발 서버 실행 확인\n4. TypeScript 타입 검사 및 린트 검사 실행",
        "subtasks": [
          {
            "id": 1,
            "title": "모노레포 구조 설정",
            "description": "Turborepo 기반 모노레포 구성, apps/ 디렉토리에 프론트엔드/백엔드 프로젝트 배치, packages/ 디렉토리에 공유 패키지 구성",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "프론트엔드 (Next.js 14) 설정",
            "description": "Next.js 14 App Router + TypeScript + ESLint 설정, Tailwind CSS 포함, apps/frontend/ 디렉토리에 완성",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "백엔드 (NestJS) 설정",
            "description": "NestJS CLI를 사용한 프로젝트 생성, TypeScript + ESLint 설정, apps/backend/ 디렉토리에 완성",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "공유 패키지 구성",
            "description": "packages/shared/ 디렉토리에 공통 타입 정의, User, Room, Message 인터페이스 및 소켓 이벤트 타입, 공통 유틸리티 함수 (generateId, formatTimestamp)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "모노레포 설정 파일",
            "description": "package.json: 워크스페이스 및 스크립트 설정, turbo.json: 빌드 파이프라인 및 캐싱 설정, tsconfig.json: 공통 TypeScript 설정",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Docker 환경 구성",
            "description": "docker-compose.yml: PostgreSQL 15, Redis 7, pgAdmin 포함, 개발 환경 네트워크 및 볼륨 설정, 포트 매핑: PostgreSQL(5432), Redis(6379), pgAdmin(5050)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "프로젝트 문서화",
            "description": "README.md: 프로젝트 구조, 실행 방법, 환경 변수 설정 가이드",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "데이터베이스 스키마 및 Prisma ORM 설정",
        "description": "PostgreSQL 데이터베이스 스키마를 설계하고 Prisma ORM을 설정하여 User, Room, Message 모델 구현",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "## 완료된 작업 내용:\n\n### ✅ Prisma CLI 설치 및 초기화\n- Prisma 6.15.0 설치 (devDependencies)\n- @prisma/client 6.15.0 설치 (dependencies)\n- prisma/schema.prisma 파일 생성 및 설정\n\n### ✅ 데이터베이스 스키마 설계\n- **User 모델**: id, email(unique), name, createdAt, updatedAt, messages 관계\n- **Room 모델**: id, name, createdAt, updatedAt, messages 관계  \n- **Message 모델**: id, content, role, createdAt, updatedAt, roomId, userId, embedding\n- **관계 설정**: User ↔ Message (1:N), Room ↔ Message (1:N), CASCADE 삭제 규칙\n\n### ✅ pgvector 확장 설정\n- docker-compose.yml을 pgvector/pgvector:pg15 이미지로 업데이트\n- PostgreSQL 컨테이너에 pgvector 확장 설치\n- Message 모델에 vector(1536) 타입의 embedding 컬럼 추가\n\n### ✅ Prisma 마이그레이션 및 테스트\n- 초기 마이그레이션 생성 및 적용 (20250902064205_init)\n- Prisma Client 생성 및 테스트\n- 데이터베이스 CRUD 작업 테스트 성공 (사용자, 채팅방, 메시지 생성/조회)\n\n### ✅ 데이터베이스 환경 구성\n- PostgreSQL 15 + pgvector 확장\n- Redis 7 (세션 및 소켓 어댑터용)\n- pgAdmin (데이터베이스 관리용)\n- Docker Compose 네트워크 구성\n\n### ✅ 문서화 및 가이드\n- README.md에 데이터베이스 스키마 상세 설명 추가\n- Prisma 명령어 및 Docker 관리 명령어 가이드 추가\n- 환경 변수 설정 방법 업데이트\n\n## 현재 데이터베이스 상태:\n- **테이블**: users, rooms, messages, _prisma_migrations\n- **확장**: pgvector (벡터 검색용)\n- **관계**: 모든 외래키 제약조건 및 CASCADE 규칙 설정 완료\n- **테스트**: CRUD 작업 및 관계 조회 테스트 성공\n\n## 다음 단계 준비 완료:\n- Task 3 (사용자 인증 시스템 구현) 진행 가능\n- Prisma Client를 NestJS 서비스에 통합할 준비 완료\n- 벡터 검색 기반 RAG 구현을 위한 데이터베이스 인프라 준비 완료",
        "testStrategy": "1. 마이그레이션 스크립트 실행 테스트 ✅\n2. 테스트 데이터 삽입 및 조회 테스트 ✅\n3. 관계 모델 쿼리 테스트 (Room-Message, User-Message) ✅\n4. pgvector 확장 기능 테스트 ✅",
        "subtasks": [
          {
            "id": 1,
            "title": "Prisma CLI 설치 및 초기화",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "데이터베이스 스키마 설계",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "pgvector 확장 설정",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Prisma 마이그레이션 및 테스트",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "데이터베이스 환경 구성",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "문서화 및 가이드",
            "description": "",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "사용자 인증 시스템 구현 (NextAuth.js + JWT)",
        "description": "NextAuth.js를 사용한 프론트엔드 인증 및 NestJS JWT 검증 시스템 구현",
        "status": "done",
        "dependencies": [
          1,
          2
        ],
        "priority": "high",
        "details": "1. NextAuth.js 설정 (Next.js 14 App Router 호환)\n2. JWT 전략 구성 및 비밀키 설정\n3. 로그인/로그아웃 API 엔드포인트 구현\n4. NestJS JWT 검증 미들웨어 구현\n5. 소켓 핸드셰이크 시 토큰 검증 로직 추가\n\n```typescript\n// frontend/src/app/api/auth/[...nextauth]/route.ts\nimport NextAuth from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\n\nconst handler = NextAuth({\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" }\n      },\n      async authorize(credentials) {\n        // API 호출하여 사용자 인증\n        const res = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/auth/login`, {\n          method: 'POST',\n          body: JSON.stringify(credentials),\n          headers: { \"Content-Type\": \"application/json\" }\n        });\n        const user = await res.json();\n        \n        if (res.ok && user) {\n          return user;\n        }\n        return null;\n      }\n    })\n  ],\n  session: {\n    strategy: \"jwt\",\n    maxAge: 30 * 24 * 60 * 60, // 30일\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token) {\n        session.user.id = token.id;\n      }\n      return session;\n    }\n  }\n});\n\nexport { handler as GET, handler as POST };\n```\n\n```typescript\n// backend/src/auth/auth.module.ts\nimport { Module } from '@nestjs/common';\nimport { JwtModule } from '@nestjs/jwt';\nimport { AuthService } from './auth.service';\nimport { AuthController } from './auth.controller';\n\n@Module({\n  imports: [\n    JwtModule.register({\n      secret: process.env.JWT_SECRET,\n      signOptions: { expiresIn: '30d' },\n    }),\n  ],\n  controllers: [AuthController],\n  providers: [AuthService],\n  exports: [AuthService],\n})\nexport class AuthModule {}\n```",
        "testStrategy": "1. 로그인/로그아웃 플로우 단위 테스트\n2. JWT 토큰 생성 및 검증 테스트\n3. 인증된/인증되지 않은 요청에 대한 API 응답 테스트\n4. 만료된 토큰 처리 테스트\n5. 소켓 연결 시 인증 테스트",
        "subtasks": [
          {
            "id": 1,
            "title": "프론트엔드 NextAuth.js 설정",
            "description": "NextAuth.js 4.24.11 설치 및 설정, JWT 전략 구성 및 30일 세션 설정, 커스텀 타입 확장 (Session, User, JWT), NextAuth.js Provider 설정 (SessionProvider)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "백엔드 JWT 인증 시스템",
            "description": "@nestjs/jwt, @nestjs/passport, passport-jwt, bcryptjs 설치, PrismaService 생성 (데이터베이스 연결 관리), AuthService 구현 (회원가입, 로그인, 사용자 검증), JWT 전략 및 가드 구현, AuthController 구현 (POST /auth/register, POST /auth/login, GET /auth/profile)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "데이터베이스 스키마 업데이트",
            "description": "User 모델에 password 필드 추가 (bcrypt 해시 저장), 새로운 마이그레이션 생성 (20250902075531_add_password_field), pgvector 확장 재설정",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "프론트엔드 인증 페이지",
            "description": "로그인 페이지 (/auth/signin) - NextAuth.js credentials provider 사용, 회원가입 페이지 (/auth/signup) - 백엔드 API 직접 호출, 반응형 UI (Tailwind CSS), 에러 처리 및 로딩 상태 관리",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "API 통합",
            "description": "NextAuth.js ↔ 백엔드 JWT 시스템 연동, Credentials Provider를 통한 사용자 인증, JWT 토큰 기반 세션 관리, 보호된 라우트 (JwtAuthGuard)",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "보안 기능",
            "description": "bcryptjs를 사용한 비밀번호 해싱 (salt rounds: 12), JWT 토큰 검증 및 만료 처리, 이메일 중복 확인, 입력 검증 및 에러 처리",
            "status": "completed",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Socket.IO 게이트웨이 구현 (NestJS)",
        "description": "NestJS에서 Socket.IO 게이트웨이를 구현하여 실시간 양방향 통신 기능 구현",
        "status": "done",
        "dependencies": [
          1,
          3
        ],
        "priority": "high",
        "details": "## 완료된 작업 내용:\n\n### ✅ 백엔드 Socket.IO 게이트웨이 구현\n- @nestjs/websockets, @nestjs/platform-socket.io, socket.io 설치\n- ChatGateway 클래스 구현 (WebSocket 게이트웨이)\n- JWT 토큰 기반 인증 미들웨어 연동\n- CORS 설정 및 네임스페이스 구성 (/chat)\n\n### ✅ 소켓 이벤트 핸들러 구현\n- **연결/해제**: handleConnection, handleDisconnect\n- **룸 관리**: join, leave 이벤트\n- **메시지 전송**: send 이벤트\n- **타이핑 상태**: typing 이벤트\n- **룸 정보**: getRooms 이벤트\n\n### ✅ 인증 및 보안 기능\n- JWT 토큰 검증 (핸드셰이크 시)\n- 사용자별 개인 룸 자동 생성\n- 인증되지 않은 연결 자동 차단\n- 에러 핸들링 및 로깅\n\n### ✅ 프론트엔드 Socket.IO 클라이언트\n- socket.io-client 설치\n- useSocket 커스텀 훅 구현\n- NextAuth.js 세션과 연동\n- 자동 연결/해제 관리\n\n### ✅ 실시간 채팅 페이지\n- /chat 페이지 구현\n- 룸 입장/퇴장 기능\n- 실시간 메시지 송수신\n- 사용자 입장/퇴장 알림\n- 연결 상태 표시\n\n### ✅ 타입 안전성\n- TypeScript 인터페이스 정의\n- AuthenticatedSocket 타입 확장\n- UserEvent, Message 인터페이스\n\n## 구현된 소켓 이벤트:\n\n### 클라이언트 → 서버\n- `join`: 룸 입장\n- `leave`: 룸 퇴장  \n- `send`: 메시지 전송\n- `typing`: 타이핑 상태 전송\n- `getRooms`: 사용자 룸 목록 조회\n\n### 서버 → 클라이언트\n- `connected`: 인증 성공 및 연결 완료\n- `message`: 새 메시지 수신\n- `userJoined`: 사용자 입장 알림\n- `userLeft`: 사용자 퇴장 알림\n- `userTyping`: 사용자 타이핑 상태\n- `error`: 에러 메시지\n\n```typescript\n// backend/src/chat/chat.gateway.ts\nimport { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayConnection, OnGatewayDisconnect } from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\nimport { AuthService } from '../auth/auth.service';\n\n@WebSocketGateway({\n  cors: {\n    origin: process.env.FRONTEND_URL,\n    credentials: true,\n  },\n  namespace: '/chat'\n})\nexport class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  @WebSocketServer() server: Server;\n\n  constructor(private authService: AuthService) {}\n\n  async handleConnection(client: Socket) {\n    try {\n      const token = client.handshake.auth.token;\n      if (!token) {\n        client.disconnect();\n        return;\n      }\n      \n      const user = await this.authService.validateToken(token);\n      if (!user) {\n        client.disconnect();\n        return;\n      }\n      \n      client.data.user = user;\n      console.log(`Client connected: ${user.id}`);\n      \n      // 사용자별 개인 룸 자동 생성\n      client.join(`user:${user.id}`);\n      \n      // 인증 성공 알림\n      client.emit('connected', { userId: user.id });\n    } catch (error) {\n      client.disconnect();\n    }\n  }\n\n  handleDisconnect(client: Socket) {\n    console.log(`Client disconnected: ${client.id}`);\n  }\n\n  @SubscribeMessage('join')\n  handleJoin(client: Socket, payload: { roomId: string }) {\n    client.join(payload.roomId);\n    \n    // 다른 사용자에게 입장 알림\n    client.to(payload.roomId).emit('userJoined', {\n      userId: client.data.user.id,\n      roomId: payload.roomId\n    });\n    \n    return { event: 'joined', data: payload };\n  }\n\n  @SubscribeMessage('leave')\n  handleLeave(client: Socket, payload: { roomId: string }) {\n    // 다른 사용자에게 퇴장 알림\n    client.to(payload.roomId).emit('userLeft', {\n      userId: client.data.user.id,\n      roomId: payload.roomId\n    });\n    \n    client.leave(payload.roomId);\n    return { event: 'left', data: payload };\n  }\n\n  @SubscribeMessage('send')\n  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {\n    const user = client.data.user;\n    \n    // 메시지 저장 로직은 별도 서비스로 분리\n    \n    this.server.to(payload.roomId).emit('message', {\n      userId: user.id,\n      text: payload.text,\n      ts: new Date().toISOString()\n    });\n    \n    return { event: 'sent', data: payload };\n  }\n  \n  @SubscribeMessage('typing')\n  handleTyping(client: Socket, payload: { roomId: string, isTyping: boolean }) {\n    const user = client.data.user;\n    \n    client.to(payload.roomId).emit('userTyping', {\n      userId: user.id,\n      isTyping: payload.isTyping\n    });\n    \n    return { event: 'typingUpdated', data: payload };\n  }\n  \n  @SubscribeMessage('getRooms')\n  handleGetRooms(client: Socket) {\n    const user = client.data.user;\n    // 사용자의 룸 목록 조회 로직\n    \n    return { event: 'rooms', data: { rooms: [] } };\n  }\n}\n```",
        "testStrategy": "## 테스트 완료 항목:\n\n1. ✅ 소켓 연결/연결 해제 테스트\n2. ✅ 인증 실패 시 연결 거부 테스트\n3. ✅ 룸 참가/퇴장 이벤트 테스트\n4. ✅ 메시지 전송 및 브로드캐스트 테스트\n5. ✅ 동시 다중 클라이언트 테스트\n6. ✅ 타이핑 상태 이벤트 테스트\n7. ✅ 사용자 입장/퇴장 알림 테스트\n8. ✅ 룸 정보 조회 테스트\n\n## 테스트 가능한 기능:\n1. **인증된 사용자만 소켓 연결 가능**\n2. **룸 기반 실시간 채팅**\n3. **사용자 입장/퇴장 알림**\n4. **타이핑 상태 실시간 표시**\n5. **다중 클라이언트 동시 연결**",
        "subtasks": [
          {
            "id": 1,
            "title": "Socket.IO 패키지 설치 및 기본 설정",
            "description": "@nestjs/websockets, @nestjs/platform-socket.io, socket.io 패키지 설치 및 기본 설정",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "ChatGateway 클래스 구현",
            "description": "WebSocketGateway 데코레이터를 사용한 기본 게이트웨이 클래스 구현 및 CORS 설정",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "인증 미들웨어 연동",
            "description": "JWT 토큰 기반 인증 미들웨어 연동 및 핸드셰이크 시 토큰 검증 로직 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "소켓 이벤트 핸들러 구현",
            "description": "join, leave, send, typing, getRooms 등 기본 이벤트 핸들러 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "프론트엔드 Socket.IO 클라이언트 구현",
            "description": "socket.io-client 설치 및 useSocket 커스텀 훅 구현, NextAuth.js 세션 연동",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "실시간 채팅 페이지 구현",
            "description": "/chat 페이지 및 실시간 메시지 송수신, 사용자 상태 표시 기능 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "타입 안전성 구현",
            "description": "TypeScript 인터페이스 정의 및 AuthenticatedSocket 타입 확장",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Redis Adapter 구현 (수평 확장 지원)",
        "description": "Socket.IO의 Redis Adapter를 구현하여 다중 서버 인스턴스 간 메시지 동기화 지원",
        "details": "1. Redis 클라이언트 설정\n2. Socket.IO Redis Adapter 구성\n3. NestJS 게이트웨이에 Redis Adapter 연결\n4. 다중 인스턴스 테스트 환경 구성\n\n```typescript\n// backend/src/chat/chat.module.ts\nimport { Module } from '@nestjs/common';\nimport { ChatGateway } from './chat.gateway';\nimport { ChatService } from './chat.service';\nimport { AuthModule } from '../auth/auth.module';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\nimport { Redis } from 'ioredis';\n\n@Module({\n  imports: [AuthModule, ConfigModule],\n  providers: [\n    ChatGateway,\n    ChatService,\n    {\n      provide: 'REDIS_ADAPTER',\n      inject: [ConfigService],\n      useFactory: (configService: ConfigService) => {\n        const pubClient = new Redis({\n          host: configService.get('REDIS_HOST'),\n          port: configService.get('REDIS_PORT'),\n        });\n        const subClient = pubClient.duplicate();\n        \n        return createAdapter(pubClient, subClient);\n      },\n    },\n  ],\n})\nexport class ChatModule {}\n```\n\n```typescript\n// backend/src/chat/chat.gateway.ts (수정)\nimport { WebSocketGateway, WebSocketServer, SubscribeMessage, OnGatewayInit } from '@nestjs/websockets';\nimport { Server } from 'socket.io';\nimport { Inject } from '@nestjs/common';\n\n@WebSocketGateway({\n  cors: {\n    origin: process.env.FRONTEND_URL,\n    credentials: true,\n  },\n})\nexport class ChatGateway implements OnGatewayInit {\n  @WebSocketServer() server: Server;\n  \n  constructor(\n    @Inject('REDIS_ADAPTER') private redisAdapter,\n    private authService: AuthService\n  ) {}\n  \n  afterInit(server: Server) {\n    server.adapter(this.redisAdapter);\n    console.log('Socket.IO server initialized with Redis adapter');\n  }\n  \n  // 기존 메서드들...\n}\n```",
        "testStrategy": "1. 단일 Redis 인스턴스 연결 테스트\n2. 다중 NestJS 인스턴스 간 메시지 전달 테스트\n3. Redis 연결 실패 시 폴백 메커니즘 테스트\n4. 부하 테스트 (다중 인스턴스에서 동시 메시지 처리)\n5. Redis 클러스터 연결 테스트",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "프론트엔드 Socket.IO 클라이언트 구현",
        "description": "Next.js 14 App Router에서 Socket.IO 클라이언트를 구현하여 실시간 메시지 송수신 기능 구현",
        "details": "1. socket.io-client 설치 및 설정\n2. 소켓 연결 관리 커스텀 훅 구현\n3. 인증 토큰 연동\n4. 이벤트 핸들러 구현 (message, stream 등)\n5. 재연결 로직 구현\n\n```typescript\n// frontend/src/lib/socket.ts\nimport { io, Socket } from 'socket.io-client';\nimport { getSession } from 'next-auth/react';\n\nlet socket: Socket | null = null;\n\nexport const initializeSocket = async (): Promise<Socket> => {\n  if (socket) return socket;\n  \n  const session = await getSession();\n  if (!session) throw new Error('Authentication required');\n  \n  socket = io(process.env.NEXT_PUBLIC_SOCKET_URL as string, {\n    auth: {\n      token: session.accessToken,\n    },\n    reconnectionAttempts: 5,\n    reconnectionDelay: 1000,\n  });\n  \n  socket.on('connect', () => {\n    console.log('Socket connected');\n  });\n  \n  socket.on('disconnect', () => {\n    console.log('Socket disconnected');\n  });\n  \n  socket.on('connect_error', (err) => {\n    console.error('Connection error:', err.message);\n  });\n  \n  return socket;\n};\n\nexport const getSocket = (): Socket => {\n  if (!socket) {\n    throw new Error('Socket not initialized');\n  }\n  return socket;\n};\n\nexport const closeSocket = (): void => {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n  }\n};\n```\n\n```typescript\n// frontend/src/hooks/useSocket.ts\nimport { useState, useEffect, useCallback } from 'react';\nimport { Socket } from 'socket.io-client';\nimport { initializeSocket, closeSocket } from '@/lib/socket';\n\nexport const useSocket = () => {\n  const [socket, setSocket] = useState<Socket | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  \n  useEffect(() => {\n    const connectSocket = async () => {\n      try {\n        const socketInstance = await initializeSocket();\n        setSocket(socketInstance);\n        \n        socketInstance.on('connect', () => setIsConnected(true));\n        socketInstance.on('disconnect', () => setIsConnected(false));\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error('Failed to connect'));\n      }\n    };\n    \n    connectSocket();\n    \n    return () => {\n      closeSocket();\n    };\n  }, []);\n  \n  const joinRoom = useCallback((roomId: string) => {\n    if (socket && isConnected) {\n      socket.emit('join', { roomId });\n    }\n  }, [socket, isConnected]);\n  \n  const leaveRoom = useCallback((roomId: string) => {\n    if (socket && isConnected) {\n      socket.emit('leave', { roomId });\n    }\n  }, [socket, isConnected]);\n  \n  const sendMessage = useCallback((roomId: string, text: string) => {\n    if (socket && isConnected) {\n      socket.emit('send', { roomId, text });\n    }\n  }, [socket, isConnected]);\n  \n  return { socket, isConnected, error, joinRoom, leaveRoom, sendMessage };\n};\n```",
        "testStrategy": "1. 소켓 연결/연결 해제 테스트\n2. 인증 토큰 전달 테스트\n3. 이벤트 송수신 테스트\n4. 네트워크 단절 시 재연결 테스트\n5. 다양한 브라우저 환경에서 호환성 테스트",
        "priority": "high",
        "dependencies": [
          1,
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "채팅 UI 구현 (Next.js)",
        "description": "Next.js로 채팅 인터페이스를 구현하여 메시지 표시, 입력, 스트리밍 응답 시각화",
        "details": "1. 채팅방 컴포넌트 구현\n2. 메시지 목록 및 입력 폼 구현\n3. 스트리밍 응답 시각화 (타이핑 효과)\n4. 메시지 상태 관리 (Zustand)\n5. 반응형 디자인 적용\n\n```typescript\n// frontend/src/store/chatStore.ts\nimport { create } from 'zustand';\n\ntype Message = {\n  id: string;\n  content: string;\n  role: 'user' | 'bot';\n  createdAt: string;\n  userId?: string;\n};\n\ntype ChatStore = {\n  messages: Record<string, Message[]>; // roomId -> messages\n  currentRoomId: string | null;\n  isStreaming: boolean;\n  streamingContent: string;\n  addMessage: (roomId: string, message: Message) => void;\n  setCurrentRoom: (roomId: string) => void;\n  startStreaming: () => void;\n  appendStreamContent: (content: string) => void;\n  endStreaming: (roomId: string) => void;\n  setMessages: (roomId: string, messages: Message[]) => void;\n};\n\nexport const useChatStore = create<ChatStore>((set) => ({\n  messages: {},\n  currentRoomId: null,\n  isStreaming: false,\n  streamingContent: '',\n  \n  addMessage: (roomId, message) => set((state) => ({\n    messages: {\n      ...state.messages,\n      [roomId]: [...(state.messages[roomId] || []), message],\n    },\n  })),\n  \n  setCurrentRoom: (roomId) => set({ currentRoomId: roomId }),\n  \n  startStreaming: () => set({ isStreaming: true, streamingContent: '' }),\n  \n  appendStreamContent: (content) => set((state) => ({\n    streamingContent: state.streamingContent + content,\n  })),\n  \n  endStreaming: (roomId) => set((state) => {\n    if (!state.currentRoomId) return state;\n    \n    const newMessage: Message = {\n      id: Date.now().toString(),\n      content: state.streamingContent,\n      role: 'bot',\n      createdAt: new Date().toISOString(),\n    };\n    \n    return {\n      isStreaming: false,\n      streamingContent: '',\n      messages: {\n        ...state.messages,\n        [roomId]: [...(state.messages[roomId] || []), newMessage],\n      },\n    };\n  }),\n  \n  setMessages: (roomId, messages) => set((state) => ({\n    messages: {\n      ...state.messages,\n      [roomId]: messages,\n    },\n  })),\n}));\n```\n\n```tsx\n// frontend/src/app/chat/[roomId]/page.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useParams } from 'next/navigation';\nimport { useSocket } from '@/hooks/useSocket';\nimport { useChatStore } from '@/store/chatStore';\nimport MessageList from '@/components/MessageList';\nimport MessageInput from '@/components/MessageInput';\n\nexport default function ChatRoom() {\n  const params = useParams();\n  const roomId = params.roomId as string;\n  const { socket, joinRoom, leaveRoom, sendMessage } = useSocket();\n  const { messages, isStreaming, streamingContent, addMessage, startStreaming, appendStreamContent, endStreaming, setMessages } = useChatStore();\n  \n  useEffect(() => {\n    if (!socket) return;\n    \n    joinRoom(roomId);\n    \n    // 기존 메시지 로드\n    fetch(`/api/rooms/${roomId}/messages`)\n      .then(res => res.json())\n      .then(data => setMessages(roomId, data));\n    \n    // 메시지 수신 이벤트\n    socket.on('message', (data) => {\n      addMessage(roomId, {\n        id: Date.now().toString(),\n        content: data.text,\n        role: data.userId ? 'user' : 'bot',\n        createdAt: data.ts,\n        userId: data.userId,\n      });\n    });\n    \n    // 스트리밍 이벤트\n    socket.on('stream', (data) => {\n      if (data.start) {\n        startStreaming();\n      } else if (data.end) {\n        endStreaming(roomId);\n      } else {\n        appendStreamContent(data.token);\n      }\n    });\n    \n    return () => {\n      leaveRoom(roomId);\n      socket.off('message');\n      socket.off('stream');\n    };\n  }, [socket, roomId]);\n  \n  const handleSendMessage = (text: string) => {\n    sendMessage(roomId, text);\n    \n    // 낙관적 업데이트\n    addMessage(roomId, {\n      id: Date.now().toString(),\n      content: text,\n      role: 'user',\n      createdAt: new Date().toISOString(),\n    });\n  };\n  \n  return (\n    <div className=\"flex flex-col h-screen\">\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        <MessageList \n          messages={messages[roomId] || []} \n          isStreaming={isStreaming}\n          streamingContent={streamingContent}\n        />\n      </div>\n      <div className=\"p-4 border-t\">\n        <MessageInput onSendMessage={handleSendMessage} disabled={isStreaming} />\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. 컴포넌트 렌더링 테스트\n2. 메시지 표시 및 스크롤 동작 테스트\n3. 메시지 입력 및 전송 테스트\n4. 스트리밍 응답 시각화 테스트\n5. 다양한 화면 크기에서 반응형 디자인 테스트",
        "priority": "high",
        "dependencies": [
          1,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "LLM API 연동 및 스트리밍 응답 구현",
        "description": "OpenAI/Anthropic API를 연동하여 챗봇 응답을 스트리밍 방식으로 처리하는 기능 구현",
        "details": "1. LLM API 클라이언트 구현 (OpenAI/Anthropic)\n2. 스트리밍 응답 처리 로직 구현\n3. 컨텍스트 관리 (대화 기록 유지)\n4. 에러 처리 및 재시도 로직\n5. 토큰 사용량 추적\n\n```typescript\n// backend/src/llm/llm.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport OpenAI from 'openai';\nimport { ChatCompletionChunk } from 'openai/resources';\n\n@Injectable()\nexport class LlmService {\n  private readonly openai: OpenAI;\n  private readonly logger = new Logger(LlmService.name);\n  \n  constructor(private configService: ConfigService) {\n    this.openai = new OpenAI({\n      apiKey: this.configService.get<string>('OPENAI_API_KEY'),\n    });\n  }\n  \n  async generateChatResponse(messages: Array<{ role: string; content: string }>, callbacks: {\n    onToken: (token: string) => void;\n    onComplete: (fullResponse: string) => void;\n    onError: (error: Error) => void;\n  }) {\n    try {\n      const stream = await this.openai.chat.completions.create({\n        model: 'gpt-4',\n        messages,\n        stream: true,\n        max_tokens: 1000,\n      });\n      \n      let fullResponse = '';\n      \n      for await (const chunk of stream) {\n        const content = chunk.choices[0]?.delta?.content || '';\n        if (content) {\n          fullResponse += content;\n          callbacks.onToken(content);\n        }\n      }\n      \n      callbacks.onComplete(fullResponse);\n      return fullResponse;\n    } catch (error) {\n      this.logger.error(`LLM API error: ${error.message}`);\n      callbacks.onError(error);\n      throw error;\n    }\n  }\n  \n  // 컨텍스트 관리를 위한 메서드\n  prepareMessages(userMessage: string, chatHistory: Array<{ role: string; content: string }>) {\n    // 시스템 프롬프트 추가\n    const messages = [\n      { role: 'system', content: 'You are a helpful assistant.' },\n      ...chatHistory,\n      { role: 'user', content: userMessage },\n    ];\n    \n    // 토큰 제한을 고려하여 필요시 이전 메시지 제거\n    return this.truncateMessages(messages);\n  }\n  \n  private truncateMessages(messages: Array<{ role: string; content: string }>) {\n    // 간단한 구현: 최근 10개 메시지만 유지\n    if (messages.length > 11) { // 시스템 메시지 + 최근 10개\n      return [messages[0], ...messages.slice(-10)];\n    }\n    return messages;\n  }\n}\n```\n\n```typescript\n// backend/src/chat/chat.gateway.ts (추가)\nimport { LlmService } from '../llm/llm.service';\nimport { PrismaService } from '../prisma/prisma.service';\n\n@WebSocketGateway()\nexport class ChatGateway {\n  // 기존 코드...\n  \n  constructor(\n    private authService: AuthService,\n    private llmService: LlmService,\n    private prismaService: PrismaService,\n  ) {}\n  \n  @SubscribeMessage('send')\n  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {\n    const user = client.data.user;\n    \n    // 사용자 메시지 저장\n    const userMessage = await this.prismaService.message.create({\n      data: {\n        content: payload.text,\n        role: 'user',\n        roomId: payload.roomId,\n        userId: user.id,\n      },\n    });\n    \n    // 클라이언트에 메시지 브로드캐스트\n    this.server.to(payload.roomId).emit('message', {\n      userId: user.id,\n      text: payload.text,\n      ts: userMessage.createdAt.toISOString(),\n    });\n    \n    // 대화 기록 조회\n    const chatHistory = await this.prismaService.message.findMany({\n      where: { roomId: payload.roomId },\n      orderBy: { createdAt: 'asc' },\n      take: 10,\n    });\n    \n    // LLM 메시지 형식으로 변환\n    const messages = chatHistory.map(msg => ({\n      role: msg.role,\n      content: msg.content,\n    }));\n    \n    // 스트리밍 시작 알림\n    this.server.to(payload.roomId).emit('stream', { start: true });\n    \n    // LLM 응답 생성\n    try {\n      await this.llmService.generateChatResponse(\n        this.llmService.prepareMessages(payload.text, messages),\n        {\n          onToken: (token) => {\n            this.server.to(payload.roomId).emit('stream', { token });\n          },\n          onComplete: async (fullResponse) => {\n            // 봇 응답 저장\n            await this.prismaService.message.create({\n              data: {\n                content: fullResponse,\n                role: 'bot',\n                roomId: payload.roomId,\n              },\n            });\n            \n            // 스트리밍 종료 알림\n            this.server.to(payload.roomId).emit('stream', { end: true });\n          },\n          onError: (error) => {\n            this.server.to(payload.roomId).emit('error', { message: 'Failed to generate response' });\n            this.server.to(payload.roomId).emit('stream', { end: true });\n          },\n        },\n      );\n    } catch (error) {\n      console.error('LLM error:', error);\n    }\n    \n    return { event: 'sent', data: payload };\n  }\n}\n```",
        "testStrategy": "1. LLM API 연결 및 응답 테스트\n2. 스트리밍 처리 테스트\n3. 에러 처리 및 재시도 로직 테스트\n4. 컨텍스트 관리 테스트 (대화 기록 유지)\n5. 토큰 사용량 추적 테스트",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "채팅방 관리 API 구현",
        "description": "채팅방 생성, 조회, 참가, 나가기 등의 기능을 제공하는 REST API 구현",
        "details": "1. 채팅방 CRUD API 엔드포인트 구현\n2. 채팅방 메시지 조회 API 구현\n3. 사용자별 채팅방 목록 조회 API 구현\n4. 권한 검증 미들웨어 적용\n5. 페이지네이션 및 필터링 지원\n\n```typescript\n// backend/src/room/room.controller.ts\nimport { Controller, Get, Post, Body, Param, UseGuards, Request, Query } from '@nestjs/common';\nimport { RoomService } from './room.service';\nimport { JwtAuthGuard } from '../auth/jwt-auth.guard';\nimport { CreateRoomDto } from './dto/create-room.dto';\n\n@Controller('rooms')\n@UseGuards(JwtAuthGuard)\nexport class RoomController {\n  constructor(private readonly roomService: RoomService) {}\n\n  @Post()\n  async create(@Body() createRoomDto: CreateRoomDto, @Request() req) {\n    return this.roomService.create(createRoomDto, req.user.id);\n  }\n\n  @Get()\n  async findAll(@Request() req, @Query() query) {\n    return this.roomService.findAllForUser(req.user.id, {\n      skip: query.skip ? parseInt(query.skip) : 0,\n      take: query.take ? parseInt(query.take) : 10,\n    });\n  }\n\n  @Get(':id')\n  async findOne(@Param('id') id: string, @Request() req) {\n    return this.roomService.findOne(id, req.user.id);\n  }\n\n  @Get(':id/messages')\n  async getMessages(\n    @Param('id') id: string,\n    @Request() req,\n    @Query() query,\n  ) {\n    return this.roomService.getMessages(id, req.user.id, {\n      skip: query.skip ? parseInt(query.skip) : 0,\n      take: query.take ? parseInt(query.take) : 50,\n    });\n  }\n}\n```\n\n```typescript\n// backend/src/room/room.service.ts\nimport { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\nimport { CreateRoomDto } from './dto/create-room.dto';\n\n@Injectable()\nexport class RoomService {\n  constructor(private prisma: PrismaService) {}\n\n  async create(createRoomDto: CreateRoomDto, userId: string) {\n    return this.prisma.room.create({\n      data: {\n        name: createRoomDto.name,\n      },\n    });\n  }\n\n  async findAllForUser(userId: string, options: { skip: number; take: number }) {\n    return this.prisma.room.findMany({\n      skip: options.skip,\n      take: options.take,\n      orderBy: {\n        createdAt: 'desc',\n      },\n    });\n  }\n\n  async findOne(id: string, userId: string) {\n    const room = await this.prisma.room.findUnique({\n      where: { id },\n    });\n\n    if (!room) {\n      throw new NotFoundException(`Room with ID ${id} not found`);\n    }\n\n    return room;\n  }\n\n  async getMessages(id: string, userId: string, options: { skip: number; take: number }) {\n    const room = await this.findOne(id, userId);\n\n    return this.prisma.message.findMany({\n      where: {\n        roomId: id,\n      },\n      orderBy: {\n        createdAt: 'asc',\n      },\n      skip: options.skip,\n      take: options.take,\n      include: {\n        user: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n    });\n  }\n}\n```",
        "testStrategy": "1. 채팅방 생성 API 테스트\n2. 채팅방 목록 조회 API 테스트\n3. 채팅방 상세 조회 API 테스트\n4. 메시지 조회 API 테스트\n5. 권한 검증 테스트\n6. 페이지네이션 및 필터링 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "벡터 검색 기반 RAG(Retrieval Augmented Generation) 구현",
        "description": "pgvector를 활용하여 이전 대화 내용을 벡터화하고 검색하여 챗봇의 컨텍스트 인식 능력 향상",
        "details": "1. pgvector 확장 설정\n2. 메시지 임베딩 생성 및 저장 로직 구현\n3. 유사도 기반 관련 메시지 검색 구현\n4. LLM 프롬프트에 검색 결과 통합\n5. 임베딩 캐싱 및 최적화\n\n```sql\n-- PostgreSQL에 pgvector 확장 설치\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- 임베딩 필드 추가 (이미 Prisma 스키마에 정의됨)\nALTER TABLE \"Message\" ADD COLUMN IF NOT EXISTS embedding vector(1536);\n```\n\n```typescript\n// backend/src/embedding/embedding.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\nimport { PrismaService } from '../prisma/prisma.service';\nimport OpenAI from 'openai';\n\n@Injectable()\nexport class EmbeddingService {\n  private readonly openai: OpenAI;\n  private readonly logger = new Logger(EmbeddingService.name);\n  \n  constructor(\n    private configService: ConfigService,\n    private prismaService: PrismaService,\n  ) {\n    this.openai = new OpenAI({\n      apiKey: this.configService.get<string>('OPENAI_API_KEY'),\n    });\n  }\n  \n  async createEmbedding(text: string): Promise<number[]> {\n    try {\n      const response = await this.openai.embeddings.create({\n        model: 'text-embedding-ada-002',\n        input: text,\n      });\n      \n      return response.data[0].embedding;\n    } catch (error) {\n      this.logger.error(`Failed to create embedding: ${error.message}`);\n      throw error;\n    }\n  }\n  \n  async storeMessageEmbedding(messageId: string, content: string): Promise<void> {\n    try {\n      const embedding = await this.createEmbedding(content);\n      \n      await this.prismaService.$executeRaw`\n        UPDATE \"Message\"\n        SET embedding = ${embedding}::vector\n        WHERE id = ${messageId}\n      `;\n    } catch (error) {\n      this.logger.error(`Failed to store message embedding: ${error.message}`);\n    }\n  }\n  \n  async findSimilarMessages(content: string, roomId: string, limit: number = 5): Promise<any[]> {\n    try {\n      const embedding = await this.createEmbedding(content);\n      \n      const similarMessages = await this.prismaService.$queryRaw`\n        SELECT id, content, role, \"createdAt\", \"userId\",\n               1 - (embedding <=> ${embedding}::vector) as similarity\n        FROM \"Message\"\n        WHERE \"roomId\" = ${roomId}\n          AND embedding IS NOT NULL\n        ORDER BY similarity DESC\n        LIMIT ${limit}\n      `;\n      \n      return similarMessages;\n    } catch (error) {\n      this.logger.error(`Failed to find similar messages: ${error.message}`);\n      return [];\n    }\n  }\n}\n```\n\n```typescript\n// backend/src/chat/chat.gateway.ts (수정)\nimport { EmbeddingService } from '../embedding/embedding.service';\n\n@WebSocketGateway()\nexport class ChatGateway {\n  constructor(\n    // 기존 의존성...\n    private embeddingService: EmbeddingService,\n  ) {}\n  \n  @SubscribeMessage('send')\n  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {\n    // 기존 코드...\n    \n    // 사용자 메시지 저장 후 임베딩 생성 (비동기로 처리)\n    const userMessage = await this.prismaService.message.create({\n      data: {\n        content: payload.text,\n        role: 'user',\n        roomId: payload.roomId,\n        userId: user.id,\n      },\n    });\n    \n    // 비동기로 임베딩 생성 및 저장\n    this.embeddingService.storeMessageEmbedding(userMessage.id, payload.text)\n      .catch(err => console.error('Failed to store embedding:', err));\n    \n    // 유사 메시지 검색\n    const similarMessages = await this.embeddingService.findSimilarMessages(\n      payload.text,\n      payload.roomId,\n    );\n    \n    // 대화 기록 조회 (최근 메시지)\n    const recentMessages = await this.prismaService.message.findMany({\n      where: { roomId: payload.roomId },\n      orderBy: { createdAt: 'desc' },\n      take: 5,\n    });\n    \n    // LLM 컨텍스트 구성 (시스템 프롬프트 + 유사 메시지 + 최근 메시지)\n    const context = [\n      { role: 'system', content: 'You are a helpful assistant.' },\n      // 유사 메시지 추가\n      ...similarMessages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      })),\n      // 최근 메시지 추가 (중복 제거)\n      ...recentMessages\n        .filter(msg => !similarMessages.some(sm => sm.id === msg.id))\n        .map(msg => ({\n          role: msg.role,\n          content: msg.content,\n        })),\n      // 현재 사용자 메시지\n      { role: 'user', content: payload.text },\n    ];\n    \n    // LLM 응답 생성 (기존 코드와 동일)\n    // ...\n  }\n}\n```",
        "testStrategy": "1. pgvector 설치 및 설정 테스트\n2. 임베딩 생성 및 저장 테스트\n3. 유사도 검색 정확도 테스트\n4. 컨텍스트 통합 및 LLM 응답 품질 테스트\n5. 성능 및 지연 시간 테스트",
        "priority": "medium",
        "dependencies": [
          2,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "멀티 디바이스 동기화 구현",
        "description": "동일 사용자의 여러 디바이스에서 접속 시 메시지 및 상태를 동기화하는 기능 구현",
        "details": "1. 사용자별 소켓 연결 관리 구현\n2. 디바이스 식별 및 그룹화 로직 구현\n3. 사용자 기반 룸 구독 관리\n4. 상태 동기화 이벤트 구현\n5. 오프라인 메시지 처리\n\n```typescript\n// backend/src/chat/user-connection.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Socket } from 'socket.io';\n\n@Injectable()\nexport class UserConnectionService {\n  // userId -> Set<socketId>\n  private userConnections: Map<string, Set<string>> = new Map();\n  // socketId -> userId\n  private socketUsers: Map<string, string> = new Map();\n  \n  addConnection(userId: string, socket: Socket): void {\n    if (!this.userConnections.has(userId)) {\n      this.userConnections.set(userId, new Set());\n    }\n    \n    this.userConnections.get(userId).add(socket.id);\n    this.socketUsers.set(socket.id, userId);\n  }\n  \n  removeConnection(socket: Socket): void {\n    const userId = this.socketUsers.get(socket.id);\n    if (!userId) return;\n    \n    this.socketUsers.delete(socket.id);\n    \n    const userSockets = this.userConnections.get(userId);\n    if (userSockets) {\n      userSockets.delete(socket.id);\n      if (userSockets.size === 0) {\n        this.userConnections.delete(userId);\n      }\n    }\n  }\n  \n  getUserSockets(userId: string): string[] {\n    const sockets = this.userConnections.get(userId);\n    return sockets ? Array.from(sockets) : [];\n  }\n  \n  getUserId(socketId: string): string | undefined {\n    return this.socketUsers.get(socketId);\n  }\n  \n  isUserOnline(userId: string): boolean {\n    const sockets = this.userConnections.get(userId);\n    return !!sockets && sockets.size > 0;\n  }\n}\n```\n\n```typescript\n// backend/src/chat/chat.gateway.ts (수정)\nimport { UserConnectionService } from './user-connection.service';\n\n@WebSocketGateway()\nexport class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {\n  constructor(\n    // 기존 의존성...\n    private userConnectionService: UserConnectionService,\n  ) {}\n  \n  async handleConnection(client: Socket) {\n    try {\n      // 기존 인증 코드...\n      \n      // 사용자 연결 추가\n      this.userConnectionService.addConnection(user.id, client);\n      \n      // 사용자가 참여 중인 룸 목록 조회\n      const rooms = await this.prismaService.room.findMany({\n        where: {\n          messages: {\n            some: {\n              userId: user.id,\n            },\n          },\n        },\n      });\n      \n      // 각 룸에 자동 참여\n      rooms.forEach(room => {\n        client.join(room.id);\n      });\n      \n      // 연결 상태 브로드캐스트 (선택적)\n      this.server.emit('user_status', {\n        userId: user.id,\n        status: 'online',\n      });\n    } catch (error) {\n      client.disconnect();\n    }\n  }\n  \n  handleDisconnect(client: Socket) {\n    const userId = this.userConnectionService.getUserId(client.id);\n    \n    // 연결 제거\n    this.userConnectionService.removeConnection(client);\n    \n    // 마지막 연결이 끊어진 경우 상태 업데이트\n    if (userId && !this.userConnectionService.isUserOnline(userId)) {\n      this.server.emit('user_status', {\n        userId,\n        status: 'offline',\n      });\n    }\n  }\n  \n  @SubscribeMessage('sync_read')\n  handleSyncRead(client: Socket, payload: { roomId: string, messageId: string }) {\n    const userId = this.userConnectionService.getUserId(client.id);\n    if (!userId) return;\n    \n    // 같은 사용자의 다른 소켓에 읽음 상태 동기화\n    const userSockets = this.userConnectionService.getUserSockets(userId);\n    \n    userSockets.forEach(socketId => {\n      if (socketId !== client.id) { // 현재 소켓 제외\n        this.server.to(socketId).emit('read_receipt', {\n          roomId: payload.roomId,\n          messageId: payload.messageId,\n          userId,\n        });\n      }\n    });\n  }\n  \n  // 기존 메서드들...\n}\n```",
        "testStrategy": "1. 다중 소켓 연결 테스트\n2. 사용자별 연결 관리 테스트\n3. 디바이스 간 메시지 동기화 테스트\n4. 연결/연결 해제 시 상태 업데이트 테스트\n5. 오프라인 메시지 처리 테스트",
        "priority": "medium",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "관리자 대시보드 구현",
        "description": "대화 로그 모니터링, 사용자 통계, 에러 로깅 등을 제공하는 관리자 대시보드 구현",
        "details": "1. 관리자 인증 및 권한 관리 구현\n2. 대화 로그 조회 및 필터링 기능 구현\n3. 사용자/방별 통계 시각화\n4. 에러 로그 모니터링\n5. LLM 토큰 사용량 추적\n\n```typescript\n// backend/src/admin/admin.controller.ts\nimport { Controller, Get, Query, UseGuards } from '@nestjs/common';\nimport { AdminService } from './admin.service';\nimport { JwtAuthGuard } from '../auth/jwt-auth.guard';\nimport { AdminGuard } from './admin.guard';\n\n@Controller('admin')\n@UseGuards(JwtAuthGuard, AdminGuard)\nexport class AdminController {\n  constructor(private readonly adminService: AdminService) {}\n\n  @Get('stats/users')\n  async getUserStats(@Query() query) {\n    return this.adminService.getUserStats({\n      startDate: query.startDate ? new Date(query.startDate) : undefined,\n      endDate: query.endDate ? new Date(query.endDate) : undefined,\n    });\n  }\n\n  @Get('stats/rooms')\n  async getRoomStats(@Query() query) {\n    return this.adminService.getRoomStats({\n      startDate: query.startDate ? new Date(query.startDate) : undefined,\n      endDate: query.endDate ? new Date(query.endDate) : undefined,\n    });\n  }\n\n  @Get('stats/messages')\n  async getMessageStats(@Query() query) {\n    return this.adminService.getMessageStats({\n      startDate: query.startDate ? new Date(query.startDate) : undefined,\n      endDate: query.endDate ? new Date(query.endDate) : undefined,\n    });\n  }\n\n  @Get('logs/errors')\n  async getErrorLogs(@Query() query) {\n    return this.adminService.getErrorLogs({\n      skip: query.skip ? parseInt(query.skip) : 0,\n      take: query.take ? parseInt(query.take) : 50,\n    });\n  }\n\n  @Get('logs/tokens')\n  async getTokenUsage(@Query() query) {\n    return this.adminService.getTokenUsage({\n      startDate: query.startDate ? new Date(query.startDate) : undefined,\n      endDate: query.endDate ? new Date(query.endDate) : undefined,\n    });\n  }\n}\n```\n\n```typescript\n// backend/src/admin/admin.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../prisma/prisma.service';\n\n@Injectable()\nexport class AdminService {\n  constructor(private prisma: PrismaService) {}\n\n  async getUserStats(options: { startDate?: Date; endDate?: Date }) {\n    const where = this.getDateFilter(options);\n\n    const totalUsers = await this.prisma.user.count();\n    const newUsers = await this.prisma.user.count({\n      where,\n    });\n\n    const activeUsers = await this.prisma.$queryRaw`\n      SELECT COUNT(DISTINCT \"userId\") \n      FROM \"Message\"\n      WHERE \"userId\" IS NOT NULL\n        AND \"createdAt\" >= ${options.startDate || new Date(0)}\n        AND \"createdAt\" <= ${options.endDate || new Date()}\n    `;\n\n    return {\n      totalUsers,\n      newUsers,\n      activeUsers: Number(activeUsers[0].count),\n    };\n  }\n\n  async getRoomStats(options: { startDate?: Date; endDate?: Date }) {\n    const where = this.getDateFilter(options);\n\n    const totalRooms = await this.prisma.room.count();\n    const newRooms = await this.prisma.room.count({\n      where,\n    });\n\n    const activeRooms = await this.prisma.$queryRaw`\n      SELECT COUNT(DISTINCT \"roomId\") \n      FROM \"Message\"\n      WHERE \"createdAt\" >= ${options.startDate || new Date(0)}\n        AND \"createdAt\" <= ${options.endDate || new Date()}\n    `;\n\n    return {\n      totalRooms,\n      newRooms,\n      activeRooms: Number(activeRooms[0].count),\n    };\n  }\n\n  async getMessageStats(options: { startDate?: Date; endDate?: Date }) {\n    const where = this.getDateFilter(options);\n\n    const totalMessages = await this.prisma.message.count();\n    const userMessages = await this.prisma.message.count({\n      where: {\n        ...where,\n        role: 'user',\n      },\n    });\n    const botMessages = await this.prisma.message.count({\n      where: {\n        ...where,\n        role: 'bot',\n      },\n    });\n\n    return {\n      totalMessages,\n      userMessages,\n      botMessages,\n    };\n  }\n\n  async getErrorLogs(options: { skip: number; take: number }) {\n    // 실제 구현에서는 별도의 에러 로그 테이블이 필요\n    return [];\n  }\n\n  async getTokenUsage(options: { startDate?: Date; endDate?: Date }) {\n    // 실제 구현에서는 별도의 토큰 사용량 추적 테이블이 필요\n    return {\n      totalTokens: 0,\n      promptTokens: 0,\n      completionTokens: 0,\n    };\n  }\n\n  private getDateFilter(options: { startDate?: Date; endDate?: Date }) {\n    const filter: any = {};\n\n    if (options.startDate || options.endDate) {\n      filter.createdAt = {};\n\n      if (options.startDate) {\n        filter.createdAt.gte = options.startDate;\n      }\n\n      if (options.endDate) {\n        filter.createdAt.lte = options.endDate;\n      }\n    }\n\n    return filter;\n  }\n}\n```\n\n```tsx\n// frontend/src/app/admin/dashboard/page.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useSession } from 'next-auth/react';\nimport { Bar, Line } from 'react-chartjs-2';\nimport { Chart, registerables } from 'chart.js';\n\nChart.register(...registerables);\n\nexport default function AdminDashboard() {\n  const { data: session } = useSession();\n  const [userStats, setUserStats] = useState(null);\n  const [roomStats, setRoomStats] = useState(null);\n  const [messageStats, setMessageStats] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    const fetchStats = async () => {\n      try {\n        const [userRes, roomRes, messageRes] = await Promise.all([\n          fetch('/api/admin/stats/users'),\n          fetch('/api/admin/stats/rooms'),\n          fetch('/api/admin/stats/messages'),\n        ]);\n        \n        const userData = await userRes.json();\n        const roomData = await roomRes.json();\n        const messageData = await messageRes.json();\n        \n        setUserStats(userData);\n        setRoomStats(roomData);\n        setMessageStats(messageData);\n      } catch (error) {\n        console.error('Failed to fetch stats:', error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    if (session) {\n      fetchStats();\n    }\n  }, [session]);\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div className=\"p-6\">\n      <h1 className=\"text-2xl font-bold mb-6\">Admin Dashboard</h1>\n      \n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\">\n        <div className=\"bg-white p-4 rounded shadow\">\n          <h2 className=\"text-lg font-semibold mb-2\">Users</h2>\n          <div className=\"text-3xl font-bold\">{userStats?.totalUsers || 0}</div>\n          <div className=\"text-sm text-gray-500\">New: {userStats?.newUsers || 0}</div>\n        </div>\n        \n        <div className=\"bg-white p-4 rounded shadow\">\n          <h2 className=\"text-lg font-semibold mb-2\">Rooms</h2>\n          <div className=\"text-3xl font-bold\">{roomStats?.totalRooms || 0}</div>\n          <div className=\"text-sm text-gray-500\">New: {roomStats?.newRooms || 0}</div>\n        </div>\n        \n        <div className=\"bg-white p-4 rounded shadow\">\n          <h2 className=\"text-lg font-semibold mb-2\">Messages</h2>\n          <div className=\"text-3xl font-bold\">{messageStats?.totalMessages || 0}</div>\n          <div className=\"text-sm text-gray-500\">\n            User: {messageStats?.userMessages || 0} / Bot: {messageStats?.botMessages || 0}\n          </div>\n        </div>\n      </div>\n      \n      {/* 차트 및 추가 통계 */}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. 관리자 인증 및 권한 테스트\n2. 통계 데이터 조회 및 계산 정확성 테스트\n3. 대시보드 UI 렌더링 테스트\n4. 필터링 및 날짜 범위 선택 테스트\n5. 차트 및 데이터 시각화 테스트",
        "priority": "low",
        "dependencies": [
          2,
          3,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "모니터링 및 로깅 시스템 구현",
        "description": "OpenTelemetry, Prometheus, Grafana를 활용한 모니터링 및 로깅 시스템 구현",
        "details": "1. OpenTelemetry 설정 및 통합\n2. Prometheus 메트릭 수집 엔드포인트 구현\n3. Grafana 대시보드 구성\n4. 로그 수집 및 분석 시스템 구현\n5. 알림 설정\n\n```typescript\n// backend/src/telemetry/telemetry.module.ts\nimport { Module } from '@nestjs/common';\nimport { PrometheusModule } from '@willsoto/nestjs-prometheus';\nimport { TelemetryService } from './telemetry.service';\nimport { OpenTelemetryModule } from 'nestjs-otel';\n\n@Module({\n  imports: [\n    PrometheusModule.register({\n      defaultMetrics: {\n        enabled: true,\n      },\n    }),\n    OpenTelemetryModule.forRoot({\n      metrics: {\n        hostMetrics: true,\n        apiMetrics: {\n          enable: true,\n        },\n      },\n    }),\n  ],\n  providers: [TelemetryService],\n  exports: [TelemetryService],\n})\nexport class TelemetryModule {}\n```\n\n```typescript\n// backend/src/telemetry/telemetry.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Counter, Gauge, Histogram } from '@willsoto/nestjs-prometheus';\nimport { InjectMetric } from '@willsoto/nestjs-prometheus';\n\n@Injectable()\nexport class TelemetryService {\n  constructor(\n    @InjectMetric('socket_connections')\n    private socketConnectionsGauge: Gauge,\n    \n    @InjectMetric('message_count')\n    private messageCounter: Counter,\n    \n    @InjectMetric('llm_response_time')\n    private llmResponseTimeHistogram: Histogram,\n    \n    @InjectMetric('llm_token_usage')\n    private llmTokenUsageCounter: Counter,\n  ) {}\n\n  recordSocketConnection(delta: number): void {\n    this.socketConnectionsGauge.inc(delta);\n  }\n\n  recordMessage(role: string): void {\n    this.messageCounter.inc({ role });\n  }\n\n  recordLlmResponseTime(durationMs: number): void {\n    this.llmResponseTimeHistogram.observe(durationMs / 1000); // 초 단위로 변환\n  }\n\n  recordTokenUsage(type: 'prompt' | 'completion', count: number): void {\n    this.llmTokenUsageCounter.inc({ type }, count);\n  }\n}\n```\n\n```typescript\n// backend/src/main.ts (수정)\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { Logger } from 'nestjs-pino';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule, {\n    bufferLogs: true,\n  });\n  \n  app.useLogger(app.get(Logger));\n  \n  // CORS 설정\n  app.enableCors({\n    origin: process.env.FRONTEND_URL,\n    credentials: true,\n  });\n  \n  await app.listen(3000);\n}\nbootstrap();\n```\n\n```yaml\n# docker-compose.yml (추가)\nversion: '3.8'\nservices:\n  # 기존 서비스...\n  \n  prometheus:\n    image: prom/prometheus:latest\n    ports:\n      - \"9090:9090\"\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n    command:\n      - '--config.file=/etc/prometheus/prometheus.yml'\n      - '--storage.tsdb.path=/prometheus'\n      - '--web.console.libraries=/usr/share/prometheus/console_libraries'\n      - '--web.console.templates=/usr/share/prometheus/consoles'\n  \n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - \"3001:3000\"\n    volumes:\n      - grafana_data:/var/lib/grafana\n    depends_on:\n      - prometheus\n\nvolumes:\n  # 기존 볼륨...\n  grafana_data:\n```\n\n```yaml\n# prometheus.yml\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'nestjs'\n    static_configs:\n      - targets: ['backend:3000']\n```",
        "testStrategy": "1. 메트릭 수집 및 보고 테스트\n2. Prometheus 엔드포인트 응답 테스트\n3. Grafana 대시보드 연결 테스트\n4. 로그 수집 및 포맷 테스트\n5. 알림 트리거 테스트",
        "priority": "low",
        "dependencies": [
          1,
          4,
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "보안 강화 및 Rate Limiting 구현",
        "description": "JWT 인증, 메시지 길이/빈도 제한, Rate Limiting 등 보안 기능 강화",
        "details": "1. JWT 토큰 보안 강화 (만료, 갱신)\n2. 소켓 연결 제한 구현\n3. 메시지 길이 및 빈도 제한 구현\n4. API Rate Limiting 구현\n5. 입력 검증 및 이스케이핑\n\n```typescript\n// backend/src/common/guards/throttle.guard.ts\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { ThrottlerException, ThrottlerOptions } from '@nestjs/throttler';\nimport { RedisService } from '../redis/redis.service';\n\n@Injectable()\nexport class SocketThrottlerGuard implements CanActivate {\n  constructor(\n    private readonly redisService: RedisService,\n    private readonly options: ThrottlerOptions = { limit: 10, ttl: 60 },\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const client = context.switchToWs().getClient();\n    const userId = client.data?.user?.id;\n    \n    if (!userId) return true; // 인증되지 않은 요청은 다른 가드에서 처리\n    \n    const event = context.getHandler().name;\n    const key = `throttle:${userId}:${event}`;\n    \n    const redis = this.redisService.getClient();\n    const current = await redis.incr(key);\n    \n    if (current === 1) {\n      await redis.expire(key, this.options.ttl);\n    }\n    \n    if (current > this.options.limit) {\n      throw new ThrottlerException();\n    }\n    \n    return true;\n  }\n}\n```\n\n```typescript\n// backend/src/chat/chat.gateway.ts (수정)\nimport { UseGuards } from '@nestjs/common';\nimport { SocketThrottlerGuard } from '../common/guards/throttle.guard';\n\n@WebSocketGateway()\nexport class ChatGateway {\n  // 기존 코드...\n  \n  @UseGuards(SocketThrottlerGuard)\n  @SubscribeMessage('send')\n  async handleMessage(client: Socket, payload: { roomId: string, text: string }) {\n    // 메시지 길이 제한\n    if (payload.text.length > 2000) {\n      client.emit('error', { message: 'Message too long' });\n      return { error: 'Message too long' };\n    }\n    \n    // 기존 코드...\n  }\n}\n```\n\n```typescript\n// backend/src/main.ts (수정)\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { ValidationPipe } from '@nestjs/common';\nimport { ThrottlerGuard, ThrottlerModule } from '@nestjs/throttler';\nimport { APP_GUARD } from '@nestjs/core';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  // 전역 검증 파이프\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true,\n      forbidNonWhitelisted: true,\n      transform: true,\n    }),\n  );\n  \n  // API Rate Limiting\n  app.register(ThrottlerModule.forRoot({\n    ttl: 60,\n    limit: 100,\n  }));\n  \n  app.register({\n    provide: APP_GUARD,\n    useClass: ThrottlerGuard,\n  });\n  \n  // 기존 코드...\n  \n  await app.listen(3000);\n}\nbootstrap();\n```\n\n```typescript\n// backend/src/auth/auth.service.ts (수정)\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private jwtService: JwtService,\n    private prismaService: PrismaService,\n  ) {}\n\n  async validateUser(email: string, password: string) {\n    const user = await this.prismaService.user.findUnique({\n      where: { email },\n    });\n\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n\n    if (!isPasswordValid) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n\n    return user;\n  }\n\n  async login(user: any) {\n    const payload = { sub: user.id, email: user.email };\n    \n    return {\n      accessToken: this.jwtService.sign(payload, { expiresIn: '1h' }),\n      refreshToken: this.jwtService.sign(payload, { expiresIn: '7d' }),\n    };\n  }\n\n  async refreshToken(refreshToken: string) {\n    try {\n      const payload = this.jwtService.verify(refreshToken);\n      const user = await this.prismaService.user.findUnique({\n        where: { id: payload.sub },\n      });\n\n      if (!user) {\n        throw new UnauthorizedException();\n      }\n\n      return {\n        accessToken: this.jwtService.sign(\n          { sub: user.id, email: user.email },\n          { expiresIn: '1h' },\n        ),\n      };\n    } catch (error) {\n      throw new UnauthorizedException('Invalid refresh token');\n    }\n  }\n}\n```",
        "testStrategy": "1. JWT 토큰 보안 테스트 (만료, 갱신)\n2. Rate Limiting 동작 테스트\n3. 메시지 길이 및 빈도 제한 테스트\n4. 입력 검증 및 이스케이핑 테스트\n5. 보안 취약점 테스트 (CSRF, XSS 등)",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "부하 테스트 및 배포 구성",
        "description": "시스템 부하 테스트 수행 및 Docker/K8s 기반 배포 환경 구성",
        "details": "1. 부하 테스트 스크립트 작성 (Artillery/k6)\n2. 다중 인스턴스 테스트\n3. Docker 이미지 빌드 스크립트 작성\n4. Kubernetes 배포 매니페스트 작성\n5. CI/CD 파이프라인 구성\n\n```javascript\n// loadtest/socket-test.js (k6 스크립트)\nimport { check, sleep } from 'k6';\nimport { randomString } from 'https://jslib.k6.io/k6-utils/1.1.0/index.js';\nimport http from 'k6/http';\nimport ws from 'k6/ws';\n\nexport const options = {\n  stages: [\n    { duration: '30s', target: 100 }, // 100명 사용자로 램프업\n    { duration: '1m', target: 100 },  // 1분간 유지\n    { duration: '30s', target: 500 }, // 500명으로 증가\n    { duration: '1m', target: 500 },  // 1분간 유지\n    { duration: '30s', target: 0 },   // 종료\n  ],\n};\n\nfunction getAuthToken() {\n  const loginRes = http.post('http://localhost:3000/auth/login', JSON.stringify({\n    email: 'test@example.com',\n    password: 'password',\n  }), {\n    headers: { 'Content-Type': 'application/json' },\n  });\n  \n  return JSON.parse(loginRes.body).accessToken;\n}\n\nexport default function() {\n  const token = getAuthToken();\n  const roomId = 'test-room-' + randomString(8);\n  \n  const url = `ws://localhost:3000/socket.io/?EIO=4&transport=websocket&auth=${token}`;\n  \n  const res = ws.connect(url, {}, function(socket) {\n    socket.on('open', () => {\n      socket.send(JSON.stringify(['join', { roomId }]));\n    });\n    \n    socket.on('message', (data) => {\n      // 메시지 처리\n    });\n    \n    socket.setInterval(function timeout() {\n      socket.send(JSON.stringify(['send', { roomId, text: 'Hello from k6 test!' }]));\n    }, 5000);\n    \n    socket.setTimeout(function() {\n      socket.close();\n    }, 60000);\n  });\n  \n  check(res, { 'Connected successfully': (r) => r && r.status === 101 });\n  \n  sleep(1);\n}\n```\n\n```yaml\n# kubernetes/deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: chatbot-backend\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: chatbot-backend\n  template:\n    metadata:\n      labels:\n        app: chatbot-backend\n    spec:\n      containers:\n      - name: backend\n        image: ${DOCKER_REGISTRY}/chatbot-backend:${VERSION}\n        ports:\n        - containerPort: 3000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: chatbot-secrets\n              key: database-url\n        - name: REDIS_HOST\n          value: redis-service\n        - name: REDIS_PORT\n          value: \"6379\"\n        - name: JWT_SECRET\n          valueFrom:\n            secretKeyRef:\n              name: chatbot-secrets\n              key: jwt-secret\n        - name: OPENAI_API_KEY\n          valueFrom:\n            secretKeyRef:\n              name: chatbot-secrets\n              key: openai-api-key\n        resources:\n          limits:\n            cpu: \"500m\"\n            memory: \"512Mi\"\n          requests:\n            cpu: \"100m\"\n            memory: \"256Mi\"\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 10\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: chatbot-backend-service\nspec:\n  selector:\n    app: chatbot-backend\n  ports:\n  - port: 80\n    targetPort: 3000\n  type: ClusterIP\n```\n\n```yaml\n# kubernetes/redis.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis:alpine\n        ports:\n        - containerPort: 6379\n        resources:\n          limits:\n            cpu: \"200m\"\n            memory: \"256Mi\"\n          requests:\n            cpu: \"100m\"\n            memory: \"128Mi\"\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-service\nspec:\n  selector:\n    app: redis\n  ports:\n  - port: 6379\n    targetPort: 6379\n  type: ClusterIP\n```\n\n```yaml\n# .github/workflows/deploy.yml\nname: Deploy\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v1\n    \n    - name: Login to DockerHub\n      uses: docker/login-action@v1\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    \n    - name: Build and push backend\n      uses: docker/build-push-action@v2\n      with:\n        context: ./apps/backend\n        push: true\n        tags: user/chatbot-backend:latest\n    \n    - name: Build and push frontend\n      uses: docker/build-push-action@v2\n      with:\n        context: ./apps/frontend\n        push: true\n        tags: user/chatbot-frontend:latest\n    \n    - name: Deploy to Kubernetes\n      uses: steebchen/kubectl@master\n      env:\n        KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}\n      with:\n        args: apply -f kubernetes/\n```",
        "testStrategy": "1. 부하 테스트 스크립트 실행 및 결과 분석\n2. 다양한 부하 시나리오 테스트\n3. Docker 이미지 빌드 및 실행 테스트\n4. Kubernetes 배포 테스트\n5. 자동화된 CI/CD 파이프라인 테스트",
        "priority": "medium",
        "dependencies": [
          4,
          5,
          8,
          13
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-09-02T01:00:44.620Z",
      "updated": "2025-09-03T01:44:21.636Z",
      "description": "Tasks for master context"
    }
  }
}